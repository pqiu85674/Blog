[{"title":"Git Branch","url":"/Blog/2024/06/17/GitBranch/","content":"\n# Git Branch\n\n假設 A 電腦跟 B 電腦都共用一個 Repositories\n在 A 及 B 電腦上先`clone`\n以下方便區分 A 及 B 電腦\n所以將 A 電腦路徑設為`./gitA/`\n\n```bash\ncd ./gitA/\ngit clone Repositories url\n```\n\nB 電腦路徑設為`./gitB/`\n\n```bash\ncd ./gitB/\ngit clone Repositories url\n```\n\n先把 A 電腦 clone 下來的檔案內容進行更改\n更改完後執行 `git add .` `git commit -m 'A Message'` `git push`\npush 完之後看一下 log `git log --oneline` 可以看到 commit 的紀錄\n這邊是故意先 push 讓其他使用者的 `git log`不同\n\n# 建立 Branch\n\n返回 B 電腦並執行\n\n```bash\ngit branch new-branch-name //建立branch\ngit branch //查看所有branch\ngit switch new-branch-name //前往建立好的branch\ngit branch //查看目前所在的branch上\n```\n\n也可以執行\n\n```bash\ngit checkout -b new-branch-name //建立branch並到此branch\ngit branch//查看目前所在的branch上\n```\n\n刪除 branch\n\n```bash\ngit branch --delete new-branch-name //刪除branch\ngit branch //查看所有branch\n```\n\npush 到遠端\n\n```bash\ngit add.\ngit commit -m 'B Message'\ngit push //出錯\ngit push -u origin HEAD  //git push -u origin new-branch-name //成功push\n```\n\n剛建立好 branch 直接 push 會失敗，因為電腦不知道你要 push 哪個 branch，所以要設定`git push -u origin HEAD`同等於`git push -u origin new-branch-name`告訴電腦要 push 的 branch，HEAD 會抓到電腦的 branch 最後一次 commit，也可以直接打 branch 的名稱\n\n到 Github 看你的 branch 就會看到兩個 branch\n可以切換到 new-branch-name 點開 commit 可以看到 B 電腦所 push 的內容，也可以查看剛剛 B 電腦修改的檔案\n看好之後切回 new-branch-name 可以看到上面綠色的`Compare & pull request`點擊下去\n點擊 Create pull request\n可以看到上面有`base`可以選擇`main`(原本的 branch) `compate` 選擇 `new-branch-name`(新的 branch)\n會出現以下錯誤\n\n`Can’t automatically merge. Don’t worry, you can still create the pull request.`\n\n這邊沒辦法直接把新的 branch 合併到原本的 branch\n\n這邊回到 B 電腦\n\n```bash\n//這邊要注意做 switch branch 以前B電腦要先commit過否則資料會消失\ngit switch main //切換到原本的branch\ngit branch //查看目前有無在main branch上\ngit pull //把main的commit內容pull到B電腦上\ngit log --oneline //B電腦查看log 可以看到只有main的commit內容(A電腦修改的部份)\ngit switch new-branch-name //切回新的branch\ngit rebase main //把目前的分支的起始點移到最新進度\n```\n\n會顯示檔案衝突要手動解決檔案的內容，這邊是使用 VS Code 直接開啟檔案就可以對檔案進行更改\n修改完檔案後\n\n```bash\ngit add .\ngit status //查看一下狀態裡面會有指令可以參考\ngit rebase --continue //解決衝突後要下此指令\ngit push //失敗\ngit push -f //成功\n```\n\n這裡`git push`失敗的原因是因為剛剛我們在 B 電腦上把 A 電腦的修改給 pull 到 B 電腦上進行合併，所以目前的 B 電腦 `git log` 是 `main` 的 commit 合併 `new-branch-name` 跟 Github 裡面 `new-branch-name` 的 commit 不一樣，所以不能`git push`\n\n這裡要用 `git push -f` 強制 push，就可以把我們合併的 commit 給 push 到 Github 的 `new-branch-name`\n\n## 注意\n\n這裡使用 `git push -f` 是將合併好的 `commit` 給 `push` 到 B 電腦所創造出來的 `new-branch-name`分支上\n但是`git push -f` **千萬不要在主要分支做使用**，只能在自己建立的 branch 分支上做使用，因為此指令會更改歷史紀錄，一旦在主要分支上使用會更改到別人的紀錄，會非常混亂\n\n再次回到 Github 並切換到 `new-branch-name` 點開 commit 可以看到已經成功更新了\n看好之後切回 `new-branch-name` 可以看到上面綠色的`Compare & pull request`點擊下去\n點擊 `Create pull request`\n可以看到上面有`base`可以選擇`main`(原本的 branch) `compate` 選擇 `new-branch-name`(新的 branch)\n看到以下訊息\nAble to merge. These branches can be automatically merged.\n代表已經可以把新建立的分支放到主要分支上了\n按下 Create pull request\n按下 Merge pull request\n按下 Confirm merge\n這樣就成功了\n可以查看 main 裡面的 commit\n","tags":["Git","Git Branch"],"categories":["Git"]},{"title":"Git Conflict","url":"/Blog/2024/06/16/GitConflict/","content":"\n# Git Conflict\n\n```bash\nmkdir dir\ncd ./dir\ncode .\ntouch index.html\n```\n\n編輯 index.html\n\n```html\n<!-- dir -->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n```\n\n推上 Github\n\n```bash\ngit init\ngit add .\ngit commit -m 'message'\ngit branch -M main\ngit remote add origin https://github.com/pqiu85674/testgit.git\ngit push -u origin main\n```\n\n建立另外一個資料夾並 clone 下來\n\n```bash\nmkdir dir2\ncd ./dir2\ncode .\ngit clone URL\n```\n\n更新原本 dir 的 index.html 內容\n\n```html\n<!-- dir -->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <h1>h1</h1>\n  </body>\n</html>\n```\n\n把 dir 的 index.html push 到 Github\n\n```bash\ngit add .\ngit commit -m 'message'\ngit push\n```\n\n更新後來建立 dir2 的 index.html 內容\n\n```html\n<!-- dir2 -->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <h1>h2</h1>\n  </body>\n</html>\n```\n\n把 dir2 的 index.html push 到 Github\n\n```bash\ngit add .\ngit commit -m 'message'\ngit push//會出現錯誤\n```\n\n這裡出現 conflict 錯誤，因為前面 dir 已經更新 index.html 的內容並且 push 到 Github，導致 dir2 要 push 時衝突到，**注意這裡是因為 dir2 更改的內容剛好與 dir 的內容不一致所導致**\n\n```bash\ngit pull --rebase\n```\n\n這邊可以解決 conflict ， VS code 會出現兩者不一致的內容讓我們做選擇，編輯好後就可以 push 到 Github\n\n```bash\ngit add .\ngit commit -m 'message'\ngit rebase --continue\ngit push\n```\n\n恭喜成功！！！\n","tags":["Git","Git Conflict"],"categories":["Git"]},{"title":"Node_Express","url":"/Blog/2024/06/06/Node_Express/","content":"\n# Express\n\nExpress 是一個簡潔且靈活的 node.js Web 應用框架, 提供了一系列强大特性幫助你創建各種 Web 應用，和豐富的 HTTP 工具。\n使用 Express 可以快速搭建一個完整功能的网站。\n\n## 建立 Express 專案\n\n```js\nnpm init\nnpm install express --save//專案安裝express\nnpm install express-generator -g//全局安裝express-generator\nexpress --view=ejs//建立專案內容\nnpm install//install package.json dependencies內容\nnpm start//啟動\n//抓取package.json\n//\"scripts\": {\n//    \"start\": \"node ./bin/www\"\n//  },\n//npm start = node ./bin/www\n```\n\n在瀏覽器上輸入`localhost:3000`就可以看到\n\n> **Express**\n> Welcome to Express\n\n\n","tags":["Node.js","Express"],"categories":["Node.js"]},{"title":"NodeAPI","url":"/Blog/2024/06/05/NodeAPI/","content":"\n# GET\n\n```js\nconst http = require(\"http\");\nconst headers = {\n  \"Access-Control-Allow-Headers\":\n    \"Content-Type, Authorization, Content-Length, X-Requested-With\",\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Methods\": \"PATCH, POST, GET,OPTIONS,DELETE\",\n  \"Content-Type\": \"application/json\",\n};\n\nfunction requestListener(req, res) {\n  if (req.method === \"GET\" && req.url === \"/\") {\n    res.writeHead(200, headers);\n    res.write(\n      //Response JSON格式\n      JSON.stringify({\n        todos: todos,\n      })\n    );\n    res.end();\n  } else {\n    res.writeHead(404, headers);\n    res.write(\n      JSON.stringify({\n        message: \"false\",\n      })\n    );\n    res.end();\n  }\n}\nconst server = http.createServer(requestListener);\nconst port = process.env.PORT || 8000;\n\nserver.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\n把 Response 單獨拉出來寫\n\n```js\n//Handle.js\n\nconst headers = {\n  \"Access-Control-Allow-Headers\":\n    \"Content-Type, Authorization, Content-Length, X-Requested-With\",\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Methods\": \"PATCH, POST, GET,OPTIONS,DELETE\",\n  \"Content-Type\": \"application/json\",\n};\nfunction SuccessHandle(res, todos, message) {\n  res.writeHead(200, headers);\n  res.write(\n    JSON.stringify({\n      status: \"true\",\n      message: message,\n      todos: todos,\n    })\n  );\n  res.end();\n}\n\nfunction ErrorHandle(res, todos, message) {\n  res.writeHead(404, headers);\n  res.write(\n    JSON.stringify({\n      status: \"false\",\n      message: message,\n      todos: todos,\n    })\n  );\n  res.end();\n}\n\nmodule.exports = {\n  SuccessHandle,\n  ErrorHandle,\n};\n```\n\n```js\n//server.js\n\nconst { SuccessHandle, ErrorHandle } = require(\"./Handle\");\n\nfunction requestListener(req, res) {\n  if (req.method === \"GET\" && req.url === \"/\") {\n    SuccessHandle(res, todos);\n  } else {\n    ErrorHandle(res, \"false\");\n  }\n}\nconst server = http.createServer(requestListener);\nconst port = process.env.PORT || 8000;\n\nserver.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\n// 處理應用程序退出信號\nconst shutdown = () => {\n  server.close(() => {\n    console.log(\"Process terminated\");\n    process.exit(0);\n  });\n};\n\nprocess.on(\"SIGTERM\", shutdown);\nprocess.on(\"SIGINT\", shutdown);\n\nserver.on(\"error\", (e) => {\n  if (e.code === \"EADDRINUSE\") {\n    console.error(`Port ${port} is already in use`);\n  } else {\n    console.error(`Server error: ${e}`);\n  }\n});\n```\n\n# POST\n\n會使用到 uuid\n\n```js\nnpm init\nnpm install uuid\n```\n\n參考連結： [uuid](https://www.npmjs.com/package/uuid)\n\n```js\nconst { v4: uuidv4 } = require(\"uuid\");\n.\n.\nelse if (req.method === \"POST\" && req.url === \"/\") {\n    req.on(\"end\", () => {\n      try {\n        const title = JSON.parse(body).title;\n        if (title !== undefined) {\n          const todo = {\n            title: title,\n            id: uuidv4(),\n          };\n          todos.push(todo);\n          SuccessHandle(res, todos, \"新增成功\");\n        } else {\n          ErrorHandle(res, \"title錯誤\");\n        }\n      } catch {\n        ErrorHandle(res, \"格式錯誤\");\n      }\n    });\n  }\n.\n.\n\n```\n\n# DELETE\n\n```js\n.\n.\nelse if (req.method === \"DELETE\" && req.url === \"/\") {\n    todos.length = 0;\n    SuccessHandle(res, todos, \"刪除成功\");\n  }\n.\n.\n```\n\n# DELETE 單比資料\n\n```js\n.\n.\nelse if (req.method === \"DELETE\" && req.url.startsWith(\"/?\")) {\n    const url = new URL(req.url, `http://${req.headers.host}`);\n    const id = url.searchParams.get(\"id\");\n    const title = url.searchParams.get(\"title\");\n\n    const beforelength = todos.length;\n\n    todos = todos.filter((item) => {\n      return item.id !== id;\n    });\n    todos = todos.filter((item) => {\n      return item.title !== title;\n    });\n    //或是以下寫法\n    // todos = todos.filter((item) => item.id !== id);\n    // todos = todos.filter((item) => item.title !== title);\n\n    const afterlength = todos.length;\n    if (beforelength > afterlength) {\n      SuccessHandle(res, todos, \"成功刪除單比資料\");\n    } else {\n      ErrorHandle(res, todos, \"沒有刪除單比資料\");\n    }\n  }\n.\n.\n```\n\n程式碼解釋\n\n` new URL(req.url, ``http://${req.headers.host}``); ` 獲取完整 url\n`url.searchParams.get(\"id\");` 取得 id\n`if (beforelength > afterlength)` 確認有無刪除資料\n\n## 實際用 Postman 操作\n\n- POST\n\n  ```json\n  {\n    \"status\": \"true\",\n    \"message\": \"新增成功\",\n    \"todos\": [\n      {\n        \"title\": \"111\",\n        \"id\": \"3497ac36-4f52-4245-a50a-26ed7a8d792d\"\n      },\n      {\n        \"title\": \"111\",\n        \"id\": \"67f49303-aaaa-4975-9dcc-c8960928f84a\"\n      }\n    ]\n  }\n  ```\n\n- DELETE\n\n  輸入網址：`http://localhost:8000/?id=3497ac36-4f52-4245-a50a-26ed7a8d792d`\n\n  ```json\n  {\n    \"status\": \"true\",\n    \"message\": \"成功刪除單比資料\",\n    \"todos\": [\n      {\n        \"title\": \"111\",\n        \"id\": \"67f49303-aaaa-4975-9dcc-c8960928f84a\"\n      }\n    ]\n  }\n  ```\n\n# OPTIONS\n\n```js\n.\n.\nelse if (req.method == \"OPTIONS\") {\n    res.writeHead(204, headers);\n    res.end();\n  }\n.\n.\n```\n\n# 完整程式碼\n\n- Handle.js\n\n```js\nconst headers = {\n  \"Access-Control-Allow-Headers\":\n    \"Content-Type, Authorization, Content-Length, X-Requested-With\",\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Methods\": \"PATCH, POST, GET,OPTIONS,DELETE\",\n  \"Content-Type\": \"application/json\",\n};\nfunction SuccessHandle(res, todos, message) {\n  res.writeHead(200, headers);\n  res.write(\n    JSON.stringify({\n      status: \"true\",\n      message: message,\n      todos: todos,\n    })\n  );\n  res.end();\n}\n\nfunction ErrorHandle(res, todos, message) {\n  res.writeHead(404, headers);\n  res.write(\n    JSON.stringify({\n      status: \"false\",\n      message: message,\n      todos: todos,\n    })\n  );\n  res.end();\n}\n\nmodule.exports = {\n  SuccessHandle,\n  ErrorHandle,\n};\n```\n\n- server.js\n\n```js\nconst http = require(\"http\");\nconst { v4: uuidv4 } = require(\"uuid\");\nconst { SuccessHandle, ErrorHandle } = require(\"./Handle\");\n\nconst headers = {\n  \"Access-Control-Allow-Headers\":\n    \"Content-Type, Authorization, Content-Length, X-Requested-With\",\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Methods\": \"PATCH, POST, GET,OPTIONS,DELETE\",\n  \"Content-Type\": \"application/json\",\n};\n\nlet todos = [];\nfunction requestListener(req, res) {\n  let body = \"\";\n  req.on(\"data\", (item) => {\n    body += item;\n  });\n\n  if (req.method === \"GET\" && req.url === \"/\") {\n    SuccessHandle(res, todos);\n  } else if (req.method === \"POST\" && req.url === \"/\") {\n    req.on(\"end\", () => {\n      try {\n        const title = JSON.parse(body).title;\n        if (title !== undefined) {\n          const todo = {\n            title: title,\n            id: uuidv4(),\n          };\n          todos.push(todo);\n          SuccessHandle(res, todos, \"新增成功\");\n        } else {\n          ErrorHandle(res, \"title錯誤\");\n        }\n      } catch {\n        ErrorHandle(res, \"格式錯誤\");\n      }\n    });\n  } else if (req.method === \"DELETE\" && req.url === \"/\") {\n    todos.length = 0;\n    SuccessHandle(res, todos, \"刪除成功\");\n  } else if (req.method === \"DELETE\" && req.url.startsWith(\"/?\")) {\n    const url = new URL(req.url, `http://${req.headers.host}`);\n    const id = url.searchParams.get(\"id\");\n    const title = url.searchParams.get(\"title\");\n\n    const beforelength = todos.length;\n\n    todos = todos.filter((item) => {\n      return item.id !== id;\n    });\n    todos = todos.filter((item) => {\n      return item.title !== title;\n    });\n    //或是以下寫法\n    // todos = todos.filter((item) => item.id !== id);\n    // todos = todos.filter((item) => item.title !== title);\n\n    const afterlength = todos.length;\n    if (beforelength > afterlength) {\n      SuccessHandle(res, todos, \"成功刪除單比資料\");\n    } else {\n      ErrorHandle(res, todos, \"沒有刪除單比資料\");\n    }\n  } else if (req.method === \"OPTIONS\") {\n    res.wirteHead(204, headers);\n    res.end();\n  } else {\n    ErrorHandle(res, \"false\");\n  }\n}\nconst server = http.createServer(requestListener);\nconst port = process.env.PORT || 8000;\n\nserver.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n\n// 處理應用程序退出信號\nconst shutdown = () => {\n  server.close(() => {\n    console.log(\"Process terminated\");\n    process.exit(0);\n  });\n};\n\nprocess.on(\"SIGTERM\", shutdown);\nprocess.on(\"SIGINT\", shutdown);\n\nserver.on(\"error\", (e) => {\n  if (e.code === \"EADDRINUSE\") {\n    console.error(`Port ${port} is already in use`);\n  } else {\n    console.error(`Server error: ${e}`);\n  }\n});\n```\n","tags":["Node.js","NodeAPI"],"categories":["Node.js"]},{"title":"NodeServer","url":"/Blog/2024/06/04/NodeServer/","content":"\n# 以 Node.js 實作一個 Server\n\n1. 建立 server.js 檔\n\n   > mkdir '資料夾名稱'\n   > cd ./資料夾名稱\n   > touch server.js\n   > code .\n\n   ```js\n   //server.js\n\n   // 引用 http 模組\n   const http = require(\"http\");\n   // 建立一個本地伺服器，設定接收到請求後的回傳資料\n   const server = http.createServer((req, res) => {\n     res.writeHead(200, { \"Content-Type\": \"text/plain\" });\n     res.write(\"Hello\");\n     res.end();\n   });\n   // 使用 8000 port\n   server.listen(8000);\n   ```\n\n2. 啟動伺服器\n\n   ```js\n   node server.js\n   ```\n\n3. 連線\n   伺服器正常運作後可以開啟瀏覽器，輸入網址`http://127.0.0.1:8000` or `localhost:8000` 就可以看到 `Hello`\n\n4. 使用 nodemon 套件\n   每次修改儲存後都需要重起 node，可以透過 npm 安裝 `nodemon` 這個套件，就能在編輯檔案後自動重新載入伺服器。\n\n   ```js\n   npm i -g nodemon//全局安裝\n\n   nodemon -v//檢查安裝版本\n\n   nodemon server.js//啟動伺服器\n   ```\n\n5. port 已經被使用\n\n   若是出現 `Error: listen EADDRINUSE: address already in use :::8000` 錯誤\n   代表 8000 port 正在使用\n\n   ```js\n   lsof -i :8000//查看是誰在使用\n   //node    277374\n\n   kill -9 277374 //把8000的port釋放出來\n\n   nodemon server.js//成功啟動伺服器\n   ```\n\n6. 連線請求\n\n   ```js\n   const http = require(\"http\");\n   const headers = {\n     \"Access-Control-Allow-Headers\":\n       \"Content-Type, Authorization, Content-Length, X-Requested-With\",\n     \"Access-Control-Allow-Origin\": \"*\",\n     \"Access-Control-Allow-Methods\": \"PATCH, POST, GET,OPTIONS,DELETE\",\n     \"Content-Type\": \"application/json\",\n   };\n   function requestListener(req, res) {\n     res.writeHead(200, headers);\n     res.write(\"Hello\");\n     res.end();\n   }\n   const server = http.createServer(requestListener);\n   const port = process.env.PORT || 8000;\n\n   server.listen(port, () => {\n     console.log(`Server is running on port ${port}`);\n   });\n\n   // 處理應用程序退出信號\n   const shutdown = () => {\n     server.close(() => {\n       console.log(\"Process terminated\");\n       process.exit(0);\n     });\n   };\n\n   process.on(\"SIGTERM\", shutdown);\n   process.on(\"SIGINT\", shutdown);\n\n   server.on(\"error\", (e) => {\n     if (e.code === \"EADDRINUSE\") {\n       console.error(`Port ${port} is already in use`);\n     } else {\n       console.error(`Server error: ${e}`);\n     }\n   });\n   ```\n\n   ## 程式碼說明\n\n   `http`： 引入 Node.js 的 HTTP，用於創建伺服器\n   `headers`： 定義 CORS，允許跨域請求\n\n   > \"Access-Control-Allow-Headers\"\n   > 作用：指定哪些 HTTP 的 Headers 設定可以在跨網域請求中發送到我的伺服器\n   > 内容：\"Content-Type, Authorization, Content-Length, X-Requested-With\"\n   > 這意味著客戶端可以在後續的實際請求中使用 Content-Type, Authorization, Content-Length, X-Requested-With\n   >\n   > \"Access-Control-Allow-Origin\"\n   > 作用：指定允許哪些網域來源可以造訪我的伺服器\n   > 内容：\\*\n   > 表示所有的網域都可造訪我的伺服器\n   >\n   > \"Access-Control-Allow-Methods\"\n   > 作用：指定允許客戶端使用的 HTTP 方法\n   > 内容：\"PATCH, POST, GET,OPTIONS,DELETE\"\n   > 表示允許使用 PATCH、POST、GET、OPTIONS 和 DELETE 方法。\n   >\n   > \"Content-Type\"\n   > 作用：指定回傳內容型別  \n   > 内容：\"application/json\"\n   > 客戶端回傳的數據型別為 JSON 格式\n\n   `requestListener` ： HTTP 的 Request 以及 Response，狀態碼設為 200，內容為 Hello\n   `http.createServer(requestListener)` ： 創建伺服器\n   `port` ： 從環境變量讀取 port，如果沒有設置則默認使用 8000 port\n   `server.listen` ： 啟動伺服器並且監聽 port 啟動成功輸出 `Server is running on port 8000`\n   `shutdown` ： 定義一個函數，當接收到退出信號時關閉伺服器並退出\n   `process.on(\"SIGTERM\", shutdown)`和`process.on(\"SIGINT\", shutdown)` ： 監聽終止信號，並調用 shutdown 關閉伺服器\n\n   > 在`nodemon server.js`啟動伺服器想要關閉時按下`ctrl+c`就是觸發`process.on(\"SIGINT\", shutdown)`\n   > 而我也可以在終端機輸入`kill -9 00000`強置關閉你正在使用的 port 會觸發`process.on(\"SIGTERM\", shutdown)`\n   > 而使用這兩種`SIGTERM`和`SIGINT`可以優雅且關閉伺服器且沒有任何數據丟失或損壞非常重要\n","tags":["Node.js","Express"],"categories":["Node.js"]},{"title":"Node.js基本知識","url":"/Blog/2024/06/04/NodePath/","content":"\n# 基本知識\n\n## Global\n\n網頁環境中的全域物件是 `window`，而 Node.js 中是 `global`\n\n- 瀏覽器\n\n  ```js\n  // 瀏覽器中的全域變數\n  var foo = \"bar\";\n  console.log(window.foo); // 'bar'\n  ```\n\n- Node.js 中的 `global`\n\n  ```js\n  // Node.js 中的全域變數\n  global.foo = \"bar\";\n  console.log(global.foo); // 'bar'\n  ```\n\n  兩個檔案（app.js 和 app2.js），裡面都分別撰寫了 `var a = 1`，`var b = 1`，這時網頁的 `window.a` 和 `window.b` 會得到 `1` 跟 `2` 的結果，Node.js 的 `global.b` 和 `global.b` 則是 undefined。\n\n  Node.js 中的每個模組都會是獨立的，不會互相干擾也不會變成全域變數（除非直接操作 global 物件）\n\n## require、module exports\n\n在 index.js 上面載入已寫好的 Object\n\n```js\n// names.js\nconst name = \"Alan\";\nconst name2 = \"Jason\";\n\n//要被載入的內容\nmodule.exports = {\n  name: name,\n  name2: name2,\n};\n```\n\n```js\n// index.js\nvar names = require(\"./names\");\nconsole.log(names);\nconsole.log(names.name);\nconsole.log(names.name2);\n\n//{name: 'Alan', name2: 'Jason'}\n//Alan\n//Jason\n```\n\n在 index.js 上面載入已寫好的 function\n\n```js\n// function.js\nfunction Hello(name) {\n  console.log(`Hello ${name}`);\n}\n\nmodule.exports = {\n  Hello,\n};\n```\n\n```js\n// index.js\nvar { Hello } = require(\"./function\");\nHello(\"Peter\");\n\n//Hello Peter\n```\n\n這裡用到解夠賦值 `var { Hello } = require(\"./function\")` 直接提取 `require(\"./function\")` 返回的對象中的 `Hello` 屬性並賦值給變量 `Hello`\n\n## **dirname、**filename\n\n```js\n//index.js\n\nconsole.log(__dirname);\n//顯示絕對路徑\n\nconsole.log(__filename);\n//顯示絕對路徑/index.js\n```\n\n## path\n\n```js\nvar url = \"/user/Users/user/Desktop/test/index.js\";\nvar path = require(\"path\");\n\n// 取得目錄\nconsole.log(path.dirname(url)); //  /user/Users/user/Desktop/test\n\n// 取得檔名\nconsole.log(path.basename(url)); //index.js\n\n// 取得副檔名\nconsole.log(path.extname(url)); //.js\n\n// 拆解路徑（回傳物件格式）\nconsole.log(path.parse(url));\n//{root: '/', dir: '/user/Users/user/Desktop/test', base: 'index.js', ext: '.js', name: 'index'}\n\n// 組合路徑\nconsole.log(path.join(path.dirname(url), path.basename(url)));\n///user/Users/user/Desktop/test/index.js\n```\n","tags":["Node.js","Global"],"categories":["Node.js"]},{"title":"認識 Node.js、NPM","url":"/Blog/2024/06/04/Node/","content":"\n# Node.js\n\nNode.js 是一個開源、跨平台的 JavaScript 執行時環境，它允許開發者在伺服器端運行 JavaScript。Node.js 採用了 Google 的 V8 JavaScript 引擎（與 Chrome 瀏覽器使用的相同），提供了高效、輕量的事件驅動架構，使其特別適用於構建高性能和可擴展的網絡應用。\n\n## 安裝\n\n- 前往官方網站下載 Node.js 安裝檔\n  官方連結：[node.js](https://nodejs.org/en)\n\n- NVM（Node Version Manager）\n  NVM 是一个 Node.js 版本管理工具，可以让你轻松地管理多个 Node.js 版本。你可以使用以下命令来安装 NVM\n\n```bash\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\n```\n\n安装完成后，你可以使用以下命令来安装 Node.js：\n\n```bash\nnvm install node\n```\n\n完成安裝後可以開啟終端機，鍵入指令 `node --version (node -v)` 來檢查版本資訊。\n\n## 簡易指令\n\n- 進入 node.js 執行環境\n\n```bash\nnode\n```\n\n- 進入環境後可以輸入 JavaScript 程式碼，就像瀏覽器的檢查工具一樣\n\n```bash\nlet a = 1\n#undefined\na\n#1\na++\n#1\na\n#2\nconsole.log('Hello, world!')\n#Hello, world!\n```\n\n- 查看可用的指令\n\n```bash\n.help\n```\n\n- 離開 node.js 環境（方法 1）\n\n```bash\n.exit\n```\n\n- 離開 node.js 環境（方法 2）\n\n```bash\n# 按兩次 Ctrl+C\nCtrl+C\nCtrl+C\n```\n\n## 執行 JS 檔案\n\n方法１：先用指令移動到 JS 檔案存放的目錄位置，再輸入指令\n\n```bash\ncd ./'專案資料夾'\nnode 檔名.js\n```\n\n方法２：直接輸入完整路徑和檔名\n\n```bash\nnode 完整路徑/檔名.js\n```\n\n# NPM\n\nNPM 是 Node Package Manager 的縮寫，是 Node.js 預設的 node 套件管理平台，npm 本機端的相關工具在安裝 node.js 時也會一起安裝，完成 Node.js 的安裝後就可以在終端機輸入指令 npm -v 來檢查版本資訊。\n\n## npm init\n\n```bash\nmkdir '資料夾名稱' #建立資料夾\ncd ./資料夾名稱 #切換路徑\nnpm init #建立package.json\n\n    package name: (test) #專案名稱\n    version: (1.0.0) #版本\n    description: #描述\n    entry point: (index.js) #進入點\n    test command: #測試指令\n    git repository: #Git 儲存庫位置\n    keywords: #關鍵字\n    author: #作者\n    license: (ISC) #開源授權方式\n\ncode . #使用VS code開啟\n```\n\n輸入完`npm init`會出現以上內容，可以按照你的情況輸入，也可按下 Enter 跳過，並且最後輸入 Y 就可以在 VS code 看到 package.json 檔案\n\n**假如你想跳過環境設定，使用預設值建立**\n\n```bash\nnpm init -y\n```\n\n**package.json 內容如下**\n\n```bash\n{\n  \"name\": \"test\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\"\n}\n```\n\n## 關於套件指令\n\n1. 安裝套件：npm install 套件名稱 或 npm i 套件名稱\n```bash\nnpm install express #安裝express\n\nnpm install uuid #安裝uuid\n```\n\n2. –save 安裝於 dependencies (已發布環境)\nnpm 安裝指令中有時會看到後面有加上 –save，如下 :\n```bash\nnpm install 套件名稱\n\nnpm install 套件名稱 --savs\n```\n`上面兩段安裝指令，其實可以說是相同的，透過 package.json 檔案我們可以看到，上面兩段指令安裝的套件，都會列於， dependencies 中。`\n\n3. –save-dev 安裝於 devDependencies (開發中環境)\nnpm 安裝指令中，如果你希望只安裝在開發環境中，可以在後面加上 –save-dev，如下 :\n```bash\nnpm install 套件名稱 --savs-dev\n```\n`加上 –save-dev 後，透過 package.json 檔案你會發現，指定安裝的套件列於 devDependencies 中。`\n\n4. 查看套件版本：npm -v\n查看已安裝的套件版本，使用 -v，如下 :\n```bash\nnpm 套件名稱 -v\n```\n你也可以使用 -v 來查看 NPM 本身的版本，如下:\n```bash\nnpm -v\n```\n\n5. 更新套件: npm update\n更新指令使用 update，如下\n```bash\nnpm update 套件名稱\n```\n\n6. 移除套件：npm uninstall 套件名稱\n```bash\nnpm uninstall '套件名稱'\n```\n\n7. 檢視所有安裝的套件：`npm ls` or `npm list`\n```bash\nnpm ls\n\n路徑/資料夾名稱\n├── express@4.16.4\n└── uuid@9.0.1\n```\n可以看到你所安裝的套件\n","tags":["Node.js"],"categories":["Node.js"]},{"title":"Hexo","url":"/Blog/2024/05/08/Hexo/","content":"\n# 安裝需求\n\n在開始安裝 Hexo 之前，必須先在電腦安裝下列工具：\n\n- Node.js\n\n- Git\n\n確認安裝版本\n\n- node.js\n```bash\nnode -v\n```\n\n- npm\n```bash\nnpm -v\n```\n\n# Hexo 環境建置\n\n- 安裝 Hexo\n```bash\nnpm install -g hexo-cli\n```\n\n- 確認安裝成功\n```bash\nhexo -v\n```\n\n- 初始化 Hexo\n```bash\nhexo init <資料夾名稱>\n```\n\n# 目錄結構\n\n- node_modules\n- scaffolds\n- source\n  - \\_posts\n- themes\n- \\_config.yml\n- .gitignore\n- package.json\n- package-lock.json\n\n## theme\n\n**加入 landscape 主題**\n\n```bash\ngit clone --depth 1 https://github.com/hexojs/hexo-theme-landscape themes/landscape\n```\n\n可參考https://github.com/hexojs/hexo-theme-landscape\n\n**加入 next 主題**\n\n```bash\ngit clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n可參考https://github.com/theme-next/hexo-theme-next\n\n其他主題可參考https://hexo.io/themes/\n\n## \\_config.yml 內容介紹\n\n- title: Hexo # 部落格名稱\n- subtitle: '' # 部落格小標題\n- description: '' # 部落格描述\n- keywords: # 部落格關鍵字\n- author: John Doe # 部落格作者\n- language: en # 部落格語系(可以調成 zh-TW)\n- timezone: '' # 標準時間\n\n# Hexo 指令\n\n常用的 Hexo 指令\n\n- 新增文章\n```bash\nhexo new '文章名稱'\n```\n\n- 產生靜態檔案\n```bash\nhexo generate\n```\n\n- 開啟模擬伺服器\n```bash\nhexo server\n```\n\n- 清除暫存檔案\n```bash\nhexo clean\n```\n\n- 產生靜態檔案並且部署到 GitHub 上\n```bash\nhexo deploy\n```\n\n## 一鍵佈署到 Github 上\n\n**在 Github 上建立一個專案並且記錄網址**\n\n- 安裝 hexo-deployer-git.\n```bash\nnpm install hexo-deployer-git --save\n```\n\n- 更改 \\_config.yml 的現有資料，並新增以下組態:\n```bash\nurl:'https://username.github.io/project'(網址要改)\n.\n.\n.\ndeploy:\n  type: git\n  repo: https://github.com/<username>/<project>(網址要改)\n  # example, https://github.com/hexojs/hexojs.github.io\n  branch: gh-pages\n```\n\n- 執行以下指令\n```bash\nhexo clean\nhexo deploy\n```\n參考連結:https://hexo.io/zh-tw/docs/github-pages\n","tags":["Hexo","Github"],"categories":["Hexo一鍵佈署到Github"]},{"title":"Hello World","url":"/Blog/1970/01/01/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]